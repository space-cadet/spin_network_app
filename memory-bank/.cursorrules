# Spin Network Visualization App Development Rules

## Project Architecture

1. This is a React application using TypeScript and built with Vite
2. The project uses Tailwind CSS for styling
3. Dependencies are managed with pnpm (not npm or yarn)
4. The app has a component-based architecture with clear separation of concerns
5. Components are organized by functionality (layouts, tools, panels, visualization)

## Data Model Patterns

1. The network data model uses TypeScript interfaces for all elements
2. Network operations return new objects rather than modifying existing ones (immutability)
3. Node IDs are unique strings with format 'node-{timestamp}-{random}'
4. Edge IDs are unique strings with format 'edge-{timestamp}-{random}'
5. All operations include validation to ensure network integrity

## Interface Patterns

1. The application uses a resizable panel system for flexible workspace customization
2. The main layout consists of:
   - Left panel for network tools
   - Center area for network visualization
   - Right panel for properties and simulation controls
   - Bottom panel for energy/metrics visualization
3. Resize handles allow users to adjust panel sizes to their preference
4. Panels maintain minimum and maximum size constraints
5. Interaction modes (select, pan, add node, add edge, delete) use visual feedback
6. Status indicators guide users through multi-step operations
7. Cursor styles change based on the current interaction mode

## Network Visualization Patterns

1. Cytoscape.js is used for network visualization
2. Network elements (nodes/edges) are selectable for property editing
3. Nodes represent intertwiners with position and intertwiner value properties
4. Edges represent spins with source, target, and spin value properties
5. The visualization supports multiple modes (select, pan, add node, add edge, delete)
6. Exercise caution when using Cytoscape.js layout functions - they can cause rendering issues
7. Always use try/catch blocks around Cytoscape.js operations that might fail
8. Prefer CSS classes for styling Cytoscape elements over direct style application
9. Use namespaced event handlers (e.g., 'tap.delete') for better event management
10. Reattach event handlers after operations that modify the graph

## Component Patterns

1. ResizablePanel is a reusable component for creating panels that can be resized by the user
2. Network generators create different types of networks (lattice, circular, random)
3. Property panels show context-sensitive controls based on selected elements
4. Interface components use consistent styling from Tailwind CSS
5. Mode buttons use toggle behavior (activeâ†’inactive) for better UX
6. Confirmation dialogs are used for destructive operations

## Coding Conventions

1. Use functional components with hooks, not class components
2. Use TypeScript interfaces for component props and data structures
3. Maintain clear type definitions for all data structures
4. Place CSS in the appropriate style files, not inline (except for dynamic values)
5. Follow the existing naming conventions for files and components
6. Use consistent indentation (2 spaces) and formatting

## State Management

1. Using Redux with Redux Toolkit for state management
2. State updates are immutable (create new objects rather than modifying existing ones)
3. Use selector functions to extract data from state where appropriate
4. Action creators are strongly typed with PayloadAction<T>
5. All hooks must be called unconditionally at the top level of components
6. Use useMemo for conditional logic that depends on state
7. Keep Redux state normalized and minimal
8. Network operations are triggered through Redux actions
9. UI state (modes, selection) is managed through the uiSlice

## Development Workflow

1. Understand existing code before making changes
2. Make incremental changes that can be easily tested
3. Consider how new features will integrate with the existing architecture
4. Maintain documentation in the memory-bank alongside code changes
5. Test UI changes across different panel configurations
6. Check different interaction modes when implementing new features
7. Consider edge cases for user interactions
