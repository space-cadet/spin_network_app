# T73b: Extracting Subsystem State Using Partial Trace
*Created: 2025-06-03*

**Description**: Fix the dimension mismatch issue in quantum graph operations by implementing partial trace-based subsystem extraction. This resolves the fundamental problem where overlapping stabilizer operations fail due to incorrect composite state management.

**Status**: ⬜ **Priority**: HIGH
**Started**: 2025-06-03
**Dependencies**: T73a (quantum graph testing), T73 (core quantum graph implementation)

## Problem Statement

The current `extractSubsystemState` function in the quantum graph module fails when operators are applied to overlapping qubit sets. For example:

1. Apply XXXX to vertices [A,B,C,D] → Creates 16-dimensional composite state
2. Apply XXXX to vertices [B,C,D,E] → Fails with dimension mismatch (128 !== 16)

**Root Cause**: The system fragments the Hilbert space into separate composite systems instead of maintaining one unified quantum state or properly extracting subsystems using partial trace.

## Solution Approach

Use partial trace operations to extract proper subsystem states from overlapping composites:

**Current (Broken)**:
```typescript
// Returns full 16-dim composite for each element in [B,C,D]
getVertexQuantumObject(B) → 16-dim composite "A_B_C_D"
```

**Fixed (Using Partial Trace)**:
```typescript
// Extract ρ_BCD from |ψ⟩_ABCD by tracing over A
partialTrace(composite_ABCD, [2,2,2,2], [0]) → 8-dim state for [B,C,D]
```

## Completion Criteria

- [x] Task created and documented
- [ ] Enhanced CompositeQuantumManager to track element-to-composite mappings
- [ ] Modified extractSubsystemState to use partial trace for overlapping subsystems
- [ ] Updated applyQuantumOperation to handle mixed individual/traced states
- [ ] Comprehensive test suite demonstrating toric code stabilizer operations
- [ ] Performance validation for larger quantum systems
- [ ] Documentation of implementation approach and limitations

## Implementation Plan

### Phase 1: Track Composite Elements (~20 lines)
**File**: `packages/quantum/src/qgraph/CompositeQuantumManager.ts`

**Essential Change**: Store which elements belong to each composite
```typescript
// Add to existing class:
private compositeElements: Map<string, string[]> = new Map();

setComposite(elementIds: string[], obj: QuantumObject): void {
  // existing code...
  this.compositeElements.set(compositeId, [...elementIds]);
}

getCompositeElements(compositeId: string): string[] {
  return this.compositeElements.get(compositeId) || [];
}
```

### Phase 2: Fix extractSubsystemState (~40 lines)
**File**: `packages/quantum/src/qgraph/operations/general.ts`

**Essential Change**: Use partial trace for overlapping elements
```typescript
export function extractSubsystemState(graph: QuantumGraph, elementIds: string[]): QuantumObject[] {
  const states: QuantumObject[] = [];
  
  for (const id of elementIds) {
    const compositeId = graph.getCompositeManager().getCompositeIdForElement(id);
    
    if (compositeId) {
      // Element is in composite - use partial trace
      const composite = graph.getCompositeQuantumObject([id]); // gets full composite
      const allElements = graph.getCompositeManager().getCompositeElements(compositeId);
      const traceOutIndices = allElements.map((_, i) => i).filter(i => allElements[i] !== id);
      
      const dims = allElements.map(() => 2); // assume qubits
      const reducedState = composite.partialTrace(dims, traceOutIndices);
      states.push(reducedState);
    } else {
      // Individual element
      const state = graph.hasNode(id) ? graph.getVertexQuantumObject(id) : graph.getEdgeQuantumObject(id);
      if (state) states.push(state);
    }
  }
  
  return states;
}
```

### Phase 3: Minor Integration (~10 lines)
**File**: `packages/quantum/src/qgraph/operations/general.ts`

**Essential Change**: Handle StateVector/Operator mixing in tensorProduct
```typescript
// Update tensorProductStates to handle mixed state types
// Add proper type checking and conversion
```

## Technical Details

### Leveraging Existing Infrastructure

The quantum package already provides comprehensive partial trace support:

- `MatrixOperator.partialTrace(dims: number[], traceOutIndices: number[])`
- `DensityMatrixOperator.partialTrace(dims: number[], traceOutIndices: number[])`
- `partialTrace()` wrapper function in `composite.ts`
- Helper functions: `indexToCoords`, `coordsToIndex`, `combineCoords`

### Example Operation Flow

**Scenario**: Apply XXXX to [B,C,D,E] after [A,B,C,D] composite exists

1. **groupElementsByComposite**: 
   - Group 1: [B,C,D] → composite "A_B_C_D"
   - Group 2: [E] → individual state

2. **extractReducedCompositeState**:
   - Get composite state |ψ⟩_ABCD (16-dimensional)
   - Calculate element positions: A=0, B=1, C=2, D=3
   - Trace out A: `partialTrace([2,2,2,2], [0])` 
   - Result: 8-dimensional state for [B,C,D]

3. **tensorProductStates**:
   - Combine 8-dim [B,C,D] state with 2-dim [E] state
   - Result: 16-dimensional state for [B,C,D,E]

4. **applyQuantumOperation**:
   - Apply XXXX operator to 16-dimensional combined state
   - Create new composite for [B,C,D,E]

### Dimension Calculations

For composite with N qubits, each of dimension 2:
- Total dimension: 2^N
- Trace out k qubits: 2^(N-k) remaining dimension
- Element indexing: binary representation of qubit states

## Expected Outcomes

### Toric Code Success Metrics
- **3x3 lattice**: All 9 X-stabilizers and 9 Z-stabilizers apply successfully
- **4x4 lattice**: All 16 X-stabilizers and 16 Z-stabilizers apply successfully  
- **No dimension mismatches**: Operations complete without errors
- **Physical consistency**: Stabilizer measurements show ±1 eigenvalues

### Performance Improvements
- **Memory efficiency**: Avoid exponential dimension explosion
- **Computational scalability**: Support larger quantum systems
- **Operation overlap**: Handle arbitrary stabilizer overlaps

## Related Files

### Core Implementation
- `packages/quantum/src/qgraph/QuantumGraph.ts` - Main quantum graph class
- `packages/quantum/src/qgraph/CompositeQuantumManager.ts` - Composite state management
- `packages/quantum/src/qgraph/operations/general.ts` - Core operation functions

### Testing and Examples
- `packages/quantum/examples/qgraph/toricCodeStabilizers.ts` - Validation example
- `packages/quantum/__tests__/qgraph/` - Test suite directory
- `packages/quantum/toric.report` - Current failure analysis

### Documentation
- `packages/quantum/docs/subsystem-extraction-plan.md` - Implementation details
- `memory-bank/tasks/T73a.md` - Testing task with architectural analysis

## Implementation Notes

### Design Principles
- **Leverage existing infrastructure**: Use proven partial trace implementations
- **Maintain API compatibility**: Keep existing QuantumGraph interface unchanged
- **Physical correctness**: Ensure partial trace operations preserve quantum mechanics
- **Performance optimization**: Minimize unnecessary state conversions

### Error Handling
- Validate composite dimensions before partial trace operations
- Handle pure vs mixed state conversions gracefully
- Provide clear error messages for invalid subsystem requests
- Fallback to current behavior if partial trace fails

### Testing Strategy
- Unit tests for each new function
- Integration tests with toric code examples
- Regression tests for existing functionality
- Performance benchmarks for larger systems

## Context

This task addresses the fundamental limitation discovered in T73a where the quantum graph module's architecture conflicts with stabilizer code requirements. Rather than redesigning the entire system, this approach fixes the core issue (dimension mismatch) while preserving the existing circuit-model paradigm.

The fix enables overlapping quantum operations on graph structures, making the module suitable for both circuit-model quantum computation and constraint-based applications like stabilizer codes.

## Progress Tracking

- [ ] **Phase 1**: Track composite elements (estimated: 1 hour)
- [ ] **Phase 2**: Fix extractSubsystemState with partial trace (estimated: 1.5 hours)  
- [ ] **Phase 3**: Handle mixed state types (estimated: 0.5 hours)

**Total Estimated Time**: 3 hours
**Implementation Complexity**: Low (simple partial trace usage)
**Risk Level**: Low (leverages existing, tested partial trace infrastructure)
