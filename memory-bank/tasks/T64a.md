# T64a: Implement @spin-network/graph-core Package

**Description**: Create a robust and reusable graph data structure package as part of the Graph-Quantum Integration Restructuring. This package will provide abstract graph algorithms and operations that can be integrated with quantum-specific extensions.

**Status**: üîÑ **Last**: 2025-05-12 23:45 IST

**Progress**:
1. Package Setup:
   - ‚úÖ Created minimal graph-core package structure
   - ‚úÖ Set up basic package.json with dependencies
   - ‚úÖ Added placeholder type definitions
   - ‚¨ú Remaining core implementation pending evaluation results

2. Evaluation Phase (graph-test-app):
   - ‚úÖ Created initial package structure
   - ‚úÖ Set up configuration files and dependencies
   - ‚úÖ Created basic application structure using template-core
   - ‚úÖ Set up routing and component templates
   - ‚¨ú Implementation of graph visualization components pending
   - ‚¨ú Graph operation functionality not started
   - ‚¨ú Backend adapters not implemented
   - ‚¨ú Performance monitoring not implemented
   - ‚¨ú Evaluation of libraries not started

**Priority**: HIGH

## Objectives

1. Create a standalone graph library with high performance and flexibility
2. Support both directed and undirected graphs with customizable properties
3. Implement core graph algorithms for traversal, search, and analysis
4. Enable straightforward integration with quantum state components
5. Provide excellent TypeScript typing and documentation

## Task Breakdown

### Phase 0: Evaluation & Prototyping
- ‚úÖ Set up minimal graph-core package
  - ‚úÖ Created basic package structure
  - ‚úÖ Added package.json with dependencies
  - ‚úÖ Created placeholder type definitions
  - ‚úÖ Set up basic exports

- üîÑ Test Application Setup (graph-test-app)
  - ‚úÖ Created basic package structure
  - ‚úÖ Set up configuration files (tsconfig.json, vite.config.ts)
  - ‚úÖ Added required dependencies
  - ‚úÖ Created basic application structure
  - ‚úÖ Set up routing configuration
  - ‚¨ú Implementation of panel components not started
  - ‚¨ú Backend selection UI not implemented
  - ‚¨ú Graph visualization not started
  - ‚¨ú Graph operation functionality not implemented
  - ‚¨ú Performance monitoring not implemented
  - ‚¨ú Library evaluation not started

- ‚¨ú Evaluation Tasks
  - ‚¨ú Implement and test Graphology adapter
  - ‚¨ú Implement and test Cytoscape.js adapter
  - ‚¨ú Perform performance benchmarks
  - ‚¨ú Compare API usability
  - ‚¨ú Document findings
  - ‚¨ú Make implementation decision

### Phase 1: Package Setup
- ‚¨ú Create graph-core directory structure
- ‚¨ú Configure graph-core package.json
- ‚¨ú Set up graph-core TypeScript configuration
- ‚¨ú Configure graph-core build system
- ‚¨ú Add appropriate entry points and exports

### Phase 2: Core Implementation
- ‚¨ú Design and implement AbstractGraph interface
- ‚¨ú Create GraphNode and GraphEdge interfaces with flexible properties
- ‚¨ú Implement core graph data structure with Map-based adjacency lists
- ‚¨ú Support directed, undirected, and mixed graph structures
- ‚¨ú Ensure graph immutability with copy-on-write patterns
- ‚¨ú Add comprehensive graph query capabilities

### Phase 3: Graph Algorithms
- ‚¨ú Implement breadth-first and depth-first traversal
- ‚¨ú Add shortest path algorithms (Dijkstra, A*)
- ‚¨ú Create minimum spanning tree algorithms
- ‚¨ú Implement graph composition utilities (merge, extract subgraph)
- ‚¨ú Add connected components detection
- ‚¨ú Create centrality measures (degree, betweenness, closeness)

### Phase 4: Integration Support
- ‚¨ú Create math.js integration for matrix operations
  - ‚¨ú Implement toAdjacencyMatrix() and toLaplacianMatrix() with weight functions
  - ‚¨ú Add support for eigenvalue/eigenvector calculations
  - ‚¨ú Create matrix-based graph algorithms (centrality, spectral)
- ‚¨ú Implement specialized graph serialization formats
  - ‚¨ú JSON serialization with full property preservation
  - ‚¨ú Optimized binary format for large graphs
  - ‚¨ú Import/export with common formats (GraphML, GML)
- ‚¨ú Develop adapters for attaching quantum states to graph elements
  - ‚¨ú Create node state attachment interface
  - ‚¨ú Implement edge state vector support
  - ‚¨ú Build intertwiner tensor attachments for nodes
- ‚¨ú Create conversion utilities for external graph formats
  - ‚¨ú Two-way conversion with Cytoscape.js format
  - ‚¨ú Import/export with networkToCytoscape compatibility
- ‚¨ú Add event emission for graph modifications
  - ‚¨ú Create observer pattern for graph changes
  - ‚¨ú Support transaction-like batched modifications

### Phase 5: Testing and Documentation
- ‚¨ú Implement comprehensive unit tests
- ‚¨ú Create performance benchmarks for large graphs
- ‚¨ú Generate API documentation with TSDoc
- ‚¨ú Create usage examples for common operations
- ‚¨ú Write integration tests with the quantum package

## Design Decisions

### Interface Hierarchy
We will implement a comprehensive interface hierarchy to support multiple use cases:

1. **Base Interfaces**
   - `IGraphElement`: Common base for all graph elements
   - `IGraphNode`: Base node interface with type support
   - `IGraphEdge`: Base edge interface with type support
   - `IPropertyMap`: Type-safe property storage

2. **Specialized Graph Interfaces**
   - `ITypedGraph<NodeType, EdgeType>`: Type-safe graph operations
   - `IOrderedGraph`: Support for ordered subgraphs (quantum circuits)
   - `ISimplicialGraph`: Support for faces and simplices (topology)
   - `IRewriteableGraph`: Pattern matching and rewrite rules

3. **Extended Structures**
   - `IFace`: 2D face representation
   - `ISimplex`: N-dimensional simplicial complex
   - `IOrderedSubgraph`: Ordered collections of elements
   - `IMatch`: Pattern matching results
   - `IRewritePattern`: Graph rewrite rules

This design supports:
- Spin networks through `ITypedGraph` and `ISimplicialGraph`
- Quantum circuits through `ITypedGraph` and `IOrderedGraph`
- ZX-calculus through `ITypedGraph` and `IRewriteableGraph`
- Pachner moves through `ISimplicialGraph` and `IRewriteableGraph`

### Implementation Strategy
- Use immutable interfaces throughout
- Support pattern matching and rewrite rules at the core
- Enable type-safe graph operations through generics
- Support higher-dimensional structures natively
- Allow composition of interfaces for specialized uses

### Algorithm Implementation
- Implement algorithms as standalone functions
- Use generator functions for lazy iteration
- Support early termination for search algorithms
- Enable custom comparators and visitor functions

## Required Files

### Core Interfaces
- `packages/graph-core/src/core/types.ts` - Base type definitions
- `packages/graph-core/src/core/interfaces/`
  - `IGraphElement.ts` - Base element interface
  - `IGraphNode.ts` - Node interface
  - `IGraphEdge.ts` - Edge interface
  - `IGraph.ts` - Core graph interface
  - `ITypedGraph.ts` - Type-safe graph interface
  - `IOrderedGraph.ts` - Ordered graph interface
  - `ISimplicialGraph.ts` - Simplicial complex interface
  - `IRewriteableGraph.ts` - Rewrite system interface

### Implementations
- `packages/graph-core/src/core/implementations/`
  - `BaseGraph.ts` - Abstract base implementation
  - `TypedGraph.ts` - Type-safe graph implementation
  - `OrderedGraph.ts` - Ordered graph implementation
  - `SimplicialGraph.ts` - Simplicial graph implementation
  - `RewriteableGraph.ts` - Rewriteable graph implementation

### Algorithms
- `packages/graph-core/src/algorithms/`
  - `traversal.ts` - Graph traversal algorithms
  - `paths.ts` - Path finding algorithms
  - `centrality.ts` - Centrality measures
  - `components.ts` - Component detection
  - `rewrite.ts` - Pattern matching and rewriting
  - `simplicial.ts` - Simplicial complex operations

### Utilities
- `packages/graph-core/src/utils/`
  - `matrix.ts` - Math.js integration
  - `serialization.ts` - Serialization utilities
  - `matching.ts` - Pattern matching utilities
  - `validation.ts` - Interface validation

### Tests
- `packages/graph-core/__tests__/`
  - `interfaces/` - Interface tests
  - `implementations/` - Implementation tests
  - `algorithms/` - Algorithm tests
  - `rewrite/` - Rewrite system tests

## Dependencies
- T64: Graph-Quantum Integration Restructuring (parent task)

## Graph Library Analysis

The following is a comprehensive comparison of JavaScript/TypeScript graph libraries that could potentially be used for this implementation:

### Comparison of JavaScript/TypeScript Graph Libraries

| Feature | Graphology | Cytoscape.js | ngraph.graph | NetworkX.js |
|---------|------------|--------------|--------------|-------------|
| **Core Features** |
| License | MIT | MIT | MIT | BSD |
| Latest Version | 0.26.0 (3 months ago) | 3.31.0 (Jan 2025) | 20.0.1 (3 years ago) | Varies |
| Weekly Downloads | ~410,000 | ~458,000 | ~25,000 | Lower |
| GitHub Stars | 1,287 | High | 521 | Lower |
| **Graph Types** |
| Directed Graphs | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Undirected Graphs | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Mixed Graphs | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ |
| Multi-Graphs | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Compound Graphs | ‚úÖ | ‚úÖ | ‚ùå | Limited |
| **TypeScript Support** |
| Native TypeScript | ‚úÖ | ‚úÖ (since 3.31.0) | ‚ùå | ‚ùå |
| Type Definitions | High Quality | Good | Community | Limited |
| **Performance** |
| Large Graph Handling | Good | Good | Excellent | Limited |
| Memory Efficiency | Good | Moderate | Excellent | Moderate |
| Speed | Good | Good | Excellent | Moderate |
| **Algorithm Support** |
| Shortest Path | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Centrality Measures | ‚úÖ | ‚úÖ | Limited | ‚úÖ |
| Community Detection | ‚úÖ | ‚úÖ | Limited | ‚úÖ |
| Minimum Spanning Tree | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Traversal Algorithms | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Integration** |
| Math.js Integration | Not Native | Not Native | Not Native | Not Native |
| Quantum Package Integration | Would Require Custom | Would Require Custom | Would Require Custom | Would Require Custom |
| **Additional Features** |
| Event System | ‚úÖ | ‚úÖ | ‚úÖ | Limited |
| Serialization | ‚úÖ (JSON) | ‚úÖ (JSON) | ‚úÖ (JSON) | ‚úÖ (JSON) |
| Layout Algorithms | Via Sigma.js | Extensive | Via Extensions | Limited |
| **Customization & Extension** |
| Plugin/Extension System | ‚úÖ | ‚úÖ | Limited | Limited |
| Custom Node/Edge Types | ‚úÖ | ‚úÖ | Limited | Limited |
| **Documentation & Community** |
| Documentation Quality | Excellent | Excellent | Good | Moderate |
| Maintenance Status | Active | Very Active | Less Active | Varies |
| Community Support | Good | Excellent | Moderate | Moderate |

### Key Library Features

**Graphology**:
- Robust TypeScript support with high-quality type definitions
- Modular architecture with numerous extensions
- Support for various graph types (directed, undirected, mixed, multi)
- Good serialization capabilities
- Active development and maintenance
- Clean and modern API

**Cytoscape.js**:
- Used in our current React app components for visualization
- Strong documentation and extensive features
- Recently added native TypeScript support (v3.31.0)
- Well-maintained with good community support
- Primarily designed for visualization but includes robust graph algorithms

**ngraph.graph**:
- Extremely performant for large graphs
- Simple, focused API
- Excellent memory efficiency
- Part of a larger ecosystem of graph-related tools
- Less active development than other options

**Graph Types Definitions**:
- **Mixed Graphs**: Graphs containing both directed and undirected edges simultaneously
- **Compound Graphs**: Hierarchical graphs where nodes can contain other nodes (parent-child relationships)

## Implementation Considerations

When choosing whether to build a custom implementation or leverage an existing library, consider:

1. **Integration Requirements**:
   - All libraries would require custom adapters for our quantum package
   - Math.js integration would need to be implemented for any choice

2. **Development Time vs. Control**:
   - Using Graphology would significantly reduce development time
   - Custom implementation provides maximum control over internals
   - A hybrid approach (wrapping Graphology) balances both concerns

3. **Current Usage**:
   - Cytoscape.js is already used in our React components, but primarily for visualization
   - Our SpinNetworkGraph class has existing custom logic that might need to be preserved

4. **Long-term Maintenance**:
   - Libraries reduce maintenance burden for core graph algorithms
   - Custom code increases maintenance needs but provides more flexibility

## Implementation Approach

### Initial Prototype: Graph Testing Application

Before committing to a full implementation strategy, we'll first create a dedicated testing application to evaluate the different graph libraries. This approach will allow for direct comparison of Graphology and Cytoscape.js in terms of API usability, performance, and integration potential.

#### Graph Testing App Structure

The test application will be created as a separate package, with common interfaces defined in graph-core:

```
/packages/graph-core/
‚îú‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ core/
    ‚îÇ   ‚îú‚îÄ‚îÄ types.ts            # Common interfaces and types
    ‚îÇ   ‚îî‚îÄ‚îÄ AbstractGraph.ts    # Interface definition for graphs

/packages/graph-test-app/
‚îú‚îÄ‚îÄ package.json            # Package configuration with both libraries as dependencies
‚îú‚îÄ‚îÄ tsconfig.json           # TypeScript configuration
‚îú‚îÄ‚îÄ vite.config.ts          # Vite build configuration
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx             # Main application component
‚îÇ   ‚îú‚îÄ‚îÄ index.tsx           # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ components/         # App-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GraphCanvas.tsx     # Graph visualization component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ControlPanel.tsx    # Left panel controls
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InfoPanel.tsx       # Right panel information
‚îÇ   ‚îú‚îÄ‚îÄ backends/           # Graph library implementations (for testing)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graphology/     # Graphology implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cytoscape/      # Cytoscape implementation
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Utility functions
‚îî‚îÄ‚îÄ public/                 # Static assets
```

This hybrid approach:
1. Defines core interfaces in graph-core (where they ultimately belong)
2. Keeps implementation experiments in graph-test-app for flexibility
3. Provides a clear path for migrating the chosen implementation to graph-core after evaluation

This test app will reuse components from the template-core package to provide a consistent UI experience with the rest of the application.

#### Testing App Features

The app will include:

1. **Left Panel**: Controls for graph operations
   - Create node
   - Create edge
   - Remove node/edge
   - Graph algorithms (e.g., shortest path, centrality)
   - Choose between Graphology/Cytoscape backends

2. **Main Panel**: Graph visualization area
   - Interactive visualization of the graph
   - Click/drag to interact with nodes/edges

3. **Right Panel**: Properties and information
   - Selected node/edge properties
   - Graph statistics
   - Performance metrics for operations

4. **Bottom Panel**: Console/logs
   - View operation results
   - See timing information
   - Debug outputs

#### Implementation Strategy

Based on the testing results, we will then proceed with the full graph-core package implementation using the better-suited library, or a custom implementation if neither meets our needs. The graph-core package will then build upon these findings to create a robust, reusable graph structure package.

## Notes
This task implements the abstract graph component of the larger T64 Graph-Quantum Integration Restructuring project. The graph-core package provides the foundation for the new architectural approach by creating abstract graph structures that can later be extended with quantum-specific functionality in the spin-network package.

Rather than building everything from scratch, we should evaluate using Graphology or other existing graph libraries as the foundation. If we choose to use an existing library, we should focus on creating appropriate wrappers and extensions that integrate well with our quantum package.

Performance will be critical, especially for large graph operations that may be needed for complex quantum networks. We should benchmark different approaches before committing to a specific implementation strategy.

Our existing SpiNetworkGraph in lib/graph contains custom implementation that already integrates with math.js for matrix operations. If we choose to use a library, we need to ensure it can either replicate this functionality or provide additional benefits that justify the migration effort.
