# T64a: Implement @spin-network/graph-core Package

**Description**: Create a robust and reusable graph data structure package as part of the Graph-Quantum Integration Restructuring. This package will provide abstract graph algorithms and operations that can be integrated with quantum-specific extensions.

**Status**: ğŸ”„ **Last**: 2025-05-12 23:30 IST

**Priority**: HIGH

## Objectives

1. Create a standalone graph library with high performance and flexibility
2. Support both directed and undirected graphs with customizable properties
3. Implement core graph algorithms for traversal, search, and analysis
4. Enable straightforward integration with quantum state components
5. Provide excellent TypeScript typing and documentation

## Task Breakdown

### Phase 1: Package Setup
- â¬œ Create packages/graph-core directory structure
- â¬œ Configure package.json with proper dependencies
- â¬œ Set up tsconfig.json for TypeScript configuration
- â¬œ Configure Vite build system
- â¬œ Add appropriate entry points and exports

### Phase 2: Core Implementation
- â¬œ Design and implement AbstractGraph interface
- â¬œ Create GraphNode and GraphEdge interfaces with flexible properties
- â¬œ Implement core graph data structure with Map-based adjacency lists
- â¬œ Support directed, undirected, and mixed graph structures
- â¬œ Ensure graph immutability with copy-on-write patterns
- â¬œ Add comprehensive graph query capabilities

### Phase 3: Graph Algorithms
- â¬œ Implement breadth-first and depth-first traversal
- â¬œ Add shortest path algorithms (Dijkstra, A*)
- â¬œ Create minimum spanning tree algorithms
- â¬œ Implement graph composition utilities (merge, extract subgraph)
- â¬œ Add connected components detection
- â¬œ Create centrality measures (degree, betweenness, closeness)

### Phase 4: Integration Support
- â¬œ Create math.js integration for matrix operations
  - â¬œ Implement toAdjacencyMatrix() and toLaplacianMatrix() with weight functions
  - â¬œ Add support for eigenvalue/eigenvector calculations
  - â¬œ Create matrix-based graph algorithms (centrality, spectral)
- â¬œ Implement specialized graph serialization formats
  - â¬œ JSON serialization with full property preservation
  - â¬œ Optimized binary format for large graphs
  - â¬œ Import/export with common formats (GraphML, GML)
- â¬œ Develop adapters for attaching quantum states to graph elements
  - â¬œ Create node state attachment interface
  - â¬œ Implement edge state vector support
  - â¬œ Build intertwiner tensor attachments for nodes
- â¬œ Create conversion utilities for external graph formats
  - â¬œ Two-way conversion with Cytoscape.js format
  - â¬œ Import/export with networkToCytoscape compatibility
- â¬œ Add event emission for graph modifications
  - â¬œ Create observer pattern for graph changes
  - â¬œ Support transaction-like batched modifications

### Phase 5: Testing and Documentation
- â¬œ Implement comprehensive unit tests
- â¬œ Create performance benchmarks for large graphs
- â¬œ Generate API documentation with TSDoc
- â¬œ Create usage examples for common operations
- â¬œ Write integration tests with the quantum package

## Design Decisions

### Graph Representation
- Use adjacency list representation for better space efficiency
- Maintain index maps for fast node and edge lookups by ID
- Store additional properties in flexible data structures for extensibility

### API Design
- Follow functional programming principles with immutable data structures
- Support method chaining for graph operations
- Provide both high-level and low-level access to graph structure
- Ensure consistent error handling and validation

### Algorithm Implementation
- Implement algorithms as standalone functions to avoid large class interfaces
- Use generator functions for lazy iteration when appropriate
- Support early termination for search algorithms
- Enable custom comparators and visitor functions

## Required Files

- `packages/graph-core/src/core/types.ts` - Core interfaces
- `packages/graph-core/src/core/AbstractGraph.ts` - Base graph implementation
- `packages/graph-core/src/algorithms/traversal.ts` - Graph traversal algorithms
- `packages/graph-core/src/algorithms/paths.ts` - Path finding algorithms
- `packages/graph-core/src/algorithms/centrality.ts` - Centrality measures
- `packages/graph-core/src/algorithms/components.ts` - Component detection
- `packages/graph-core/src/utils/matrix.ts` - Math.js integration
- `packages/graph-core/src/utils/serialization.ts` - Serialization utilities
- `packages/graph-core/__tests__/` - Test suite directory

## Dependencies
- T64: Graph-Quantum Integration Restructuring (parent task)

## Graph Library Analysis

The following is a comprehensive comparison of JavaScript/TypeScript graph libraries that could potentially be used for this implementation:

### Comparison of JavaScript/TypeScript Graph Libraries

| Feature | Graphology | Cytoscape.js | ngraph.graph | NetworkX.js |
|---------|------------|--------------|--------------|-------------|
| **Core Features** |
| License | MIT | MIT | MIT | BSD |
| Latest Version | 0.26.0 (3 months ago) | 3.31.0 (Jan 2025) | 20.0.1 (3 years ago) | Varies |
| Weekly Downloads | ~410,000 | ~458,000 | ~25,000 | Lower |
| GitHub Stars | 1,287 | High | 521 | Lower |
| **Graph Types** |
| Directed Graphs | âœ… | âœ… | âœ… | âœ… |
| Undirected Graphs | âœ… | âœ… | âœ… | âœ… |
| Mixed Graphs | âœ… | âœ… | âŒ | âœ… |
| Multi-Graphs | âœ… | âœ… | âœ… | âœ… |
| Compound Graphs | âœ… | âœ… | âŒ | Limited |
| **TypeScript Support** |
| Native TypeScript | âœ… | âœ… (since 3.31.0) | âŒ | âŒ |
| Type Definitions | High Quality | Good | Community | Limited |
| **Performance** |
| Large Graph Handling | Good | Good | Excellent | Limited |
| Memory Efficiency | Good | Moderate | Excellent | Moderate |
| Speed | Good | Good | Excellent | Moderate |
| **Algorithm Support** |
| Shortest Path | âœ… | âœ… | âœ… | âœ… |
| Centrality Measures | âœ… | âœ… | Limited | âœ… |
| Community Detection | âœ… | âœ… | Limited | âœ… |
| Minimum Spanning Tree | âœ… | âœ… | âœ… | âœ… |
| Traversal Algorithms | âœ… | âœ… | âœ… | âœ… |
| **Integration** |
| Math.js Integration | Not Native | Not Native | Not Native | Not Native |
| Quantum Package Integration | Would Require Custom | Would Require Custom | Would Require Custom | Would Require Custom |
| **Additional Features** |
| Event System | âœ… | âœ… | âœ… | Limited |
| Serialization | âœ… (JSON) | âœ… (JSON) | âœ… (JSON) | âœ… (JSON) |
| Layout Algorithms | Via Sigma.js | Extensive | Via Extensions | Limited |
| **Customization & Extension** |
| Plugin/Extension System | âœ… | âœ… | Limited | Limited |
| Custom Node/Edge Types | âœ… | âœ… | Limited | Limited |
| **Documentation & Community** |
| Documentation Quality | Excellent | Excellent | Good | Moderate |
| Maintenance Status | Active | Very Active | Less Active | Varies |
| Community Support | Good | Excellent | Moderate | Moderate |

### Key Library Features

**Graphology**:
- Robust TypeScript support with high-quality type definitions
- Modular architecture with numerous extensions
- Support for various graph types (directed, undirected, mixed, multi)
- Good serialization capabilities
- Active development and maintenance
- Clean and modern API

**Cytoscape.js**:
- Used in our current React app components for visualization
- Strong documentation and extensive features
- Recently added native TypeScript support (v3.31.0)
- Well-maintained with good community support
- Primarily designed for visualization but includes robust graph algorithms

**ngraph.graph**:
- Extremely performant for large graphs
- Simple, focused API
- Excellent memory efficiency
- Part of a larger ecosystem of graph-related tools
- Less active development than other options

**Graph Types Definitions**:
- **Mixed Graphs**: Graphs containing both directed and undirected edges simultaneously
- **Compound Graphs**: Hierarchical graphs where nodes can contain other nodes (parent-child relationships)

## Implementation Considerations

When choosing whether to build a custom implementation or leverage an existing library, consider:

1. **Integration Requirements**:
   - All libraries would require custom adapters for our quantum package
   - Math.js integration would need to be implemented for any choice

2. **Development Time vs. Control**:
   - Using Graphology would significantly reduce development time
   - Custom implementation provides maximum control over internals
   - A hybrid approach (wrapping Graphology) balances both concerns

3. **Current Usage**:
   - Cytoscape.js is already used in our React components, but primarily for visualization
   - Our SpinNetworkGraph class has existing custom logic that might need to be preserved

4. **Long-term Maintenance**:
   - Libraries reduce maintenance burden for core graph algorithms
   - Custom code increases maintenance needs but provides more flexibility

## Implementation Approach

### Initial Prototype: Graph Testing Application

Before committing to a full implementation strategy, we'll first create a dedicated testing application to evaluate the different graph libraries. This approach will allow for direct comparison of Graphology and Cytoscape.js in terms of API usability, performance, and integration potential.

#### Graph Testing App Structure

The test application will be created as a separate package, with common interfaces defined in graph-core:

```
/packages/graph-core/
â”œâ”€â”€ src/
    â”œâ”€â”€ core/
    â”‚   â”œâ”€â”€ types.ts            # Common interfaces and types
    â”‚   â””â”€â”€ AbstractGraph.ts    # Interface definition for graphs

/packages/graph-test-app/
â”œâ”€â”€ package.json            # Package configuration with both libraries as dependencies
â”œâ”€â”€ tsconfig.json           # TypeScript configuration
â”œâ”€â”€ vite.config.ts          # Vite build configuration
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ App.tsx             # Main application component
â”‚   â”œâ”€â”€ index.tsx           # Entry point
â”‚   â”œâ”€â”€ components/         # App-specific components
â”‚   â”‚   â”œâ”€â”€ GraphCanvas.tsx     # Graph visualization component
â”‚   â”‚   â”œâ”€â”€ ControlPanel.tsx    # Left panel controls
â”‚   â”‚   â””â”€â”€ InfoPanel.tsx       # Right panel information
â”‚   â”œâ”€â”€ backends/           # Graph library implementations (for testing)
â”‚   â”‚   â”œâ”€â”€ graphology/     # Graphology implementation
â”‚   â”‚   â””â”€â”€ cytoscape/      # Cytoscape implementation
â”‚   â””â”€â”€ utils/              # Utility functions
â””â”€â”€ public/                 # Static assets
```

This hybrid approach:
1. Defines core interfaces in graph-core (where they ultimately belong)
2. Keeps implementation experiments in graph-test-app for flexibility
3. Provides a clear path for migrating the chosen implementation to graph-core after evaluation

This test app will reuse components from the template-core package to provide a consistent UI experience with the rest of the application.

#### Testing App Features

The app will include:

1. **Left Panel**: Controls for graph operations
   - Create node
   - Create edge
   - Remove node/edge
   - Graph algorithms (e.g., shortest path, centrality)
   - Choose between Graphology/Cytoscape backends

2. **Main Panel**: Graph visualization area
   - Interactive visualization of the graph
   - Click/drag to interact with nodes/edges

3. **Right Panel**: Properties and information
   - Selected node/edge properties
   - Graph statistics
   - Performance metrics for operations

4. **Bottom Panel**: Console/logs
   - View operation results
   - See timing information
   - Debug outputs

#### Implementation Strategy

Based on the testing results, we will then proceed with the full graph-core package implementation using the better-suited library, or a custom implementation if neither meets our needs. The graph-core package will then build upon these findings to create a robust, reusable graph structure package.

## Notes
This task implements the abstract graph component of the larger T64 Graph-Quantum Integration Restructuring project. The graph-core package provides the foundation for the new architectural approach by creating abstract graph structures that can later be extended with quantum-specific functionality in the spin-network package.

Rather than building everything from scratch, we should evaluate using Graphology or other existing graph libraries as the foundation. If we choose to use an existing library, we should focus on creating appropriate wrappers and extensions that integrate well with our quantum package.

Performance will be critical, especially for large graph operations that may be needed for complex quantum networks. We should benchmark different approaches before committing to a specific implementation strategy.

Our existing SpiNetworkGraph in lib/graph contains custom implementation that already integrates with math.js for matrix operations. If we choose to use a library, we need to ensure it can either replicate this functionality or provide additional benefits that justify the migration effort.
